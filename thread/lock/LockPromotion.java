package thread.lock;

/**
 * {@since JDK1.6} JVM 引入了锁升级机制来优化 synchronized 关键字
 * ------------------------------偏向锁------------------------------
 * 偏向锁主要用来优化同一线程多次申请同一个锁的竞争
 * 在某些情况下,大部分时间是同一个线程竞争锁资源 eg: 在创建一个线程并在线程中执行循环监听的场景下,或单线程操作一个
 * 线程安全的集合时,同一个线程都需要获取和释放锁,每次操作都会发生用户态和内核态的切换
 * <p>
 * 偏向锁的作用: 当一个线程再次访问这个同步代码块时,该线程只需去对象头的 Mark Word 中判断一下是否有偏向锁指向
 * 它的 ID,无需在进入 Monitor 去竞争对象了;当一个对象的MonitorObject被一个线程持有时,对象头中的锁标志位是01
 * "是否偏向锁"标志位设置为1,并且记录线程ID,表示进入偏向锁状态
 * <p>
 * 一旦出现其他线程竞争锁资源时,偏向锁就会被撤销;偏向锁的撤销需要等待全局安全点,暂停持有该锁的线程,同时检查该线程
 * 是否还在执行该方法,如果是,则升级锁;反之则被其他线程抢占
 * <p>
 * ----------------------------------------------------------------
 * 锁升级过程: 当一个线程获得锁时,首先对象锁将成为一个偏向锁,为了优化同一线程重复获取导致的用户态与内核态的切换问题;其次
 * 如果有多个线程竞争锁资源,锁将会升级为轻量级锁,它适用于在短时间内持有锁,且线程交替切换的场景; 轻量级锁还使用了自旋锁
 * 来避免线程用户态与内核态的频繁切换,大大地提高了系统性能,但如果锁竞争太激烈,那么同步锁将会升级为重量级锁
 * ----------------------------------------------------------------
 * 减少锁竞争 是优化 synchronized 同步锁的关键
 * VM 参数{@code -XX:-UseBiasedLocking} 关闭偏向锁(默认打开)
 * VM 参数{@code -XX:+UseHeavyMonitors} 设置重量级锁
 * VM 参数{@code -XX:-UseSpinning} 关闭自旋锁优化(默认打开)
 * VM 参数{@code -XX:PreBlockSpin} 修改默认的自旋次数;在JDK1.7去掉该参数,自旋次数由JVM 控制
 * ----------------------------------------------------------------
 * 多线程对锁资源的竞争会引起上下文切换,还有锁竞争导致的线程阻塞越多,上下文切换就越频繁,系统的性能开销也就越大
 * 所以在多线程编程中,锁其实不是性能开销的根源,竞争锁才是
 * @author zqw
 * @date 2022/7/2
 */
class LockPromotion {
    public static void main(String[] args) {
        System.out.println("LockPromotion");
    }
}
