package jvm;

/**
 * Java 虚拟机识别方法的关键在于类名,方法名以及方法描述符(method descriptor).
 * 方法描述符: 由方法的的参数类型以及返回类型所构成.
 * 在同一个类中,如果同时出现多个名字相同且方法描述符也相同的方法,那么 Java 虚拟机在类
 * 的验证阶段就会报错.
 * --------------------------- 多态 ---------------------------
 * 方法重写是多态最重要的一种体现方式: 它允许子类在继承父类部分功能的同时,拥有自己独特的行为.
 * --------- Java 虚拟机 与 Java 语言判定重写与重载的不同 ---------
 * Java 虚拟机与 Java 语言不同,它并不限制名字与参数类型相同,但返回类型不同的方法出现在同一个
 * 类中;对于调用这些方法的字节码来说,由于字节码所附带的方法描述符包含了返回类型,因此 Java 虚拟
 * 机能够准确地识别目标方法.
 * Java 虚拟机中关于方法重写的判定同样基于方法描述符;如果子类定义了与父类中非私有,非静态方法相
 * 同的方法,那么只有当这两个方法的参数类型以及返回类型一致时,Java 虚拟机才会判定为重写.
 * 由于对于重载方法的区分在编译阶段已经完成 所以 Java 虚拟机不存在重载这一概念.
 * 对于 Java 语言中重写而 Java 虚拟机中非重写的情况,编译器会通过生成[桥接方法]来实现Java中重
 * 写语义.
 * 重载: 静态绑定 编译时多态(在Java虚拟机语境下并非完全正确 因为某个类中的重载方法可能被它的子
 * 类所重写.
 * 因此 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型)
 * 重写  动态绑定 运行时多态
 * --------------------------- 静态绑定 ---------------------------
 * Java 虚拟机在解析时便能够直接识别目标方法
 * --------------------------- 动态绑定 ---------------------------
 * Java 虚拟机需要在运行过程中根据调用者的动态类型来识别目标方法
 * --------------------------- invoke instruction ---------------------------
 * 1. invokestatic: 用于调用静态方法
 * 2. invokespecial: 用于调用私有实例方法、构造器以及使用super关键字调用父类的实例方法或构
 * 造器和所实现接口的默认方法.
 * 3. invokevirtual: 用于调用非私有实例方法(可以重写的方法)
 * 4. invokeinterface: 用于调用接口方法
 * 5. invokedynamic: 用于调用动态方法(lambda)
 * 对于 invokestatic 和 invokespecial 而言,虚拟机能够直接识别具体方法;而对于invokevirtual
 * invokeinterface 而言,在绝大部分情况下,虚拟机需要在执行过程中,根据调用者的动态类型,来确定具体的目标方法
 * 唯一的列外就是,被final修饰的方法
 * --------------------------- 符号引用 ---------------------------
 * 在编译过程中,对于动态绑定 Java 编译器不知道目标方法的具体内存地址,因此 Java 编译器会暂时使用符号引用来
 * 表示目标方法, 其包括目标方法所在的类或接口的名字以及目标方法名和方法描述符; 符号引用储存在class文件的常量池
 * 之中; 根据目标方法是否为接口方法,这些引用可以分为接口符号引用和非接口符号引用.
 * 在class文件中,Java编译器会用符号引用代替目标方法,在执行调用指令前,它所附带的符号引用需要被解析成实际引用
 * 对于可以静态绑定的方法调用而言,实际引用为目标方法的指针,对于需要动态绑定的方法而言,实际引用为辅助动态绑定的信息.
 * --------------------------- 内联缓存 ---------------------------
 * 内联缓存是一种加快动态绑定的优化技术;它能够缓存虚方法调用中者的动态类型,以及该类型所对应的目标方法;
 * 在之后的执行过程中,如果碰到已缓存的类型,内联缓存便会直接调用该类型对应的目标方法;如果没有碰到已缓存
 * 的类型,内联缓存则会退化至使用基于方法表的动态绑定
 * @author zqw
 * @date 2022/7/9
 */
public class OverrideAndOverload {
    public static void main(String[] args) {
        System.out.println("OverrideAndOverload");
    }

}

@SuppressWarnings("unused")
class  Father {
    void f(int a, double b) {
        System.out.println(a * b);
    }

    static void print() {
        System.out.println("print Father");
    }
}

@SuppressWarnings("unused")
class Son extends Father {
    // 如果这两个方法都是静态的,那么子类中的方法隐藏了父类中的方法
    // 如果这两个方法都不是静态的,且都不是私有的,那么子类的方法重写了父类的方法

    static void print() {
        System.out.println("print Son");
    }

    void f(double a, double b) {
        System.out.println(a * b);
    }

    void g() {
        // 除了同一类中的方法,重载也可以作用于这个类所继承而来的方法
        // 如果子类定义了与父类中非私有方法同名的方法,且这两个方法的参数,类型不同
        // 那么在子类中,这两个方法同样构成重载
        f(2, 1.0);
        f(3, 2.0);
        f(2.0, 1.0);
    }

    public static void main(String[] args) {
        Son son = new Son();
        son.g();
        son.f(1.2, 2.3);
    }
}